
import android.content.SharedPreferences;import android.os.Bundle;import android.text.Editable;import android.text.TextWatcher;import android.util.Log;import android.view.View;import android.widget.ArrayAdapter;import android.widget.EditText;import android.widget.GridView;import android.widget.ImageView;import android.widget.Toast;import android.content.Context;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AlertDialog;import androidx.appcompat.app.AppCompatActivity;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;import androidx.recyclerview.widget.LinearLayoutManager;import androidx.recyclerview.widget.RecyclerView;import com.androidappm.studyplus.adapter.MessageAdapter;import com.androidappm.studyplus.interface_study.ApiService;import com.androidappm.studyplus.modelclasses.Message;import com.androidappm.studyplus.modelclasses.MessageResponse;import com.androidappm.studyplus.modelclasses.SendMessageRequest;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;import java.net.URISyntaxException;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Collections;import java.util.Date;import java.util.List;import java.util.Locale;import io.socket.client.IO;import io.socket.client.Socket;import io.socket.emitter.Emitter;import retrofit2.Call;import retrofit2.Callback;import retrofit2.Response;public class MainActivity extends AppCompatActivity {    private static final String TAG = "MainActivity";    private static final String SOCKET_URL = "wss://api.studypulse.live/";    private Socket mSocket;    private EditText inputMessage;    private ImageView sendMessageButton,voice_button,emojiButton;    private final String discussionId = "6799fff4db0e4a39f88c19d3"; // Example discussion ID    private String token;    private RecyclerView chatRecycview;    private MessageAdapter messageAdapter;    private List<Message> messagesList = new ArrayList<>();    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_main);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -> {            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        });        // Retrieve token from SharedPreferences        token = getToken();        if (token != null) {            Log.d(TAG, "Token retrieved: " + token);            initializeSocketConnection();            fetchMessages();        } else {            Log.e(TAG, "Token not found. Cannot initialize socket connection.");        }        initializeViews();    }    // Function to update messages when required    public void updateMessageList(List<Message> newMessages) {        if (messageAdapter != null) {            messageAdapter.updateMessages(newMessages);  // Only call if adapter is initialized        } else {            Log.e("MainActivity", "MessageAdapter is null");        }    }    // Dummy function for initial messages    private List<Message> getInitialMessages() {        // Add some initial messages here        return new ArrayList<>();  // Return your actual list of messages    }    private String getToken() {        SharedPreferences sharedPreferences = getSharedPreferences("MyPrefs", Context.MODE_PRIVATE);        return sharedPreferences.getString("auth_token", null);    }    private void initializeViews() {        inputMessage = findViewById(R.id.inputMessage);        sendMessageButton = findViewById(R.id.send_button);        voice_button=findViewById(R.id.voice_button);       emojiButton = findViewById(R.id.emoji_button);     emojiButton.setOnClickListener(v -> openEmojiPicker());        // Set the click listener on the emoji button        // Set inputType to text only (no suggestions)//        emojiButton.setOnClickListener(new View.OnClickListener() {//            @Override//            public void onClick(View v) {////                inputMessage.requestFocus();//////                InputMethodManager imm = (InputMethodManager) getSystemService(INPUT_METHOD_SERVICE);//                imm.showSoftInput(inputMessage, InputMethodManager.SHOW_FORCED);//////            }//        });// Set a TextWatcher on inputMessage EditText        inputMessage.addTextChangedListener(new TextWatcher() {            @Override            public void beforeTextChanged(CharSequence s, int start, int count, int after) {                // No action needed here            }            @Override            public void onTextChanged(CharSequence s, int start, int before, int count) {                if (s.length() > 0) {                    // Show the send button, hide the voice button                    sendMessageButton.setVisibility(View.VISIBLE);                    voice_button.setVisibility(View.GONE);                } else {                    // Hide the send button, show the voice button                    sendMessageButton.setVisibility(View.GONE);                    voice_button.setVisibility(View.VISIBLE);                }            }            @Override            public void afterTextChanged(Editable editable) {            }        });        chatRecycview = findViewById(R.id.chatRecycview);        if (chatRecycview != null) {            LinearLayoutManager layoutManager = new LinearLayoutManager(this);            layoutManager.setStackFromEnd(true);  // Ensure RecyclerView starts at the bottom            chatRecycview.setLayoutManager(layoutManager);        } else {            Log.e("MainActivity", "RecyclerView is null");        }        // Use the global messageAdapter instead of redeclaring it        messageAdapter = new MessageAdapter(messagesList); // Now use the global messageAdapter        // Set the adapter to the RecyclerView        chatRecycview.setAdapter(messageAdapter);        chatRecycview.addOnScrollListener(new RecyclerView.OnScrollListener() {            @Override            public void onScrolled(RecyclerView recyclerView, int dx, int dy) {                super.onScrolled(recyclerView, dx, dy);                // Check if user has scrolled to the bottom                if (!isLoading && !recyclerView.canScrollVertically(1)) {                    fetchMessages();  // Fetch next set of messages                }            }        });        // Set the button listener to send the message        sendMessageButton.setOnClickListener(v -> sendMessage());    }    private void openEmojiPicker() {        final String[] emojis = new String[] {                "ğŸ˜Š", "ğŸ˜‚", "ğŸ˜", "ğŸ˜¢", "ğŸ˜", "ğŸ˜œ", "ğŸ¥º", "ğŸ¤”", "ğŸ˜‹",                "ğŸ¥°", "ğŸ˜…", "ğŸ˜±", "ğŸ˜‡", "ğŸ˜", "ğŸ˜†", "ğŸ¤©", "ğŸ™ƒ", "ğŸ¤—", "ğŸ˜ˆ",                "ğŸ¥³", "ğŸ˜œ", "ğŸ˜", "ğŸ˜Œ", "ğŸ˜“", "ğŸ¤­", "ğŸ¤«", "ğŸ˜¬", "ğŸ˜–", "ğŸ¥´",                "ğŸ«£", "ğŸ«¶", "ğŸ˜œ", "ğŸ˜¬", "ğŸ˜£", "ğŸ¤¤", "ğŸ˜³", "ğŸ« ", "ğŸ«£", "ğŸ¤ª"        };        // Create a custom layout to hold the GridView        GridView gridView = new GridView(this);        gridView.setNumColumns(5); // Set the number of columns in the grid        gridView.setAdapter(new ArrayAdapter<>(this, android.R.layout.simple_list_item_1, emojis));        // Create the AlertDialog        AlertDialog.Builder builder = new AlertDialog.Builder(this);        builder.setTitle("Select Emoji");        builder.setView(gridView); // Set the GridView as the content of the dialog        // Create the dialog        AlertDialog dialog = builder.create();        // Set the item click listener        gridView.setOnItemClickListener((parent, view, position, id) -> {            String selectedEmoji = emojis[position];            inputMessage.append(selectedEmoji); // Append the emoji to the EditText            dialog.dismiss(); // Dismiss the dialog        });        // Show the dialog        dialog.show();    }//    private void sendMessage() {//        String messageContent = inputMessage.getText().toString().trim();////        // Check if the message is empty//        if (messageContent.isEmpty()) {//            Toast.makeText(this, "Message cannot be empty", Toast.LENGTH_SHORT).show();//            return;//        }////        String token = getToken();//        if (token == null || token.isEmpty()) {//            Log.e(TAG, "Token is missing or invalid");//            Toast.makeText(this, "Token is missing or invalid", Toast.LENGTH_SHORT).show();//            return;//        }////        String chapterCurriculumId = "6772987f9bf198648073cc45"; // Example chapter ID//        String discussionId = "6772987f9bf198648073cc4f"; // Example discussion ID//        String messageType = "text";////        // Create request object for the message//        SendMessageRequest sendMessageRequest = new SendMessageRequest(chapterCurriculumId, discussionId, messageType, messageContent);////        ApiService apiService = RetrofitClient.getClient().create(ApiService.class);//        Call<Void> call = apiService.sendMessageInDiscussion("Bearer " + token, sendMessageRequest);////        call.enqueue(new Callback<Void>() {//            @Override//            public void onResponse(Call<Void> call, Response<Void> response) {//                if (response.isSuccessful()) {//                    Log.d(TAG, "Message sent successfully");//                    Toast.makeText(MainActivity.this, "Message sent successfully", Toast.LENGTH_SHORT).show();////                    // Create a new Message object for the sent message////                    Message sentMessage = new Message(messageContent, String.valueOf(System.currentTimeMillis()), new SenderDetails("You", "", "you@example.com"));////                    // Add the sent message to the messages list//                    messagesList.add(sentMessage);////                    // Notify the adapter that a new message has been added//                    messageAdapter.notifyItemInserted(messagesList.size() - 1);////                    // Scroll RecyclerView to show the new message//                    chatRecycview.scrollToPosition(messagesList.size() - 1);////                    // Show a Toast indicating the message was added to the RecyclerView//                    Toast.makeText(MainActivity.this, "Message added to RecyclerView", Toast.LENGTH_SHORT).show();//                    Toast.makeText(MainActivity.this, "Message from You: \"" + messageContent + "\" added to RecyclerView", Toast.LENGTH_SHORT).show();////                    // Optionally, clear the input field//                    inputMessage.setText("");//                } else {//                    Log.e(TAG, "Error sending message: " + response.code());//                    Toast.makeText(MainActivity.this, "Failed to send message", Toast.LENGTH_SHORT).show();//                }//            }////            @Override//            public void onFailure(Call<Void> call, Throwable t) {//                Log.e(TAG, "API call failed: " + t.getMessage());//                Toast.makeText(MainActivity.this, "Error occurred while sending message", Toast.LENGTH_SHORT).show();//            }//        });//    }    private void sendMessage() {        // Retrieve the message from input field        String messageContent = inputMessage.getText().toString().trim();        // Check if the message is empty        if (messageContent.isEmpty()) {            Toast.makeText(this, "Message cannot be empty", Toast.LENGTH_SHORT).show();            return;        }        // Retrieve token from SharedPreferences        String token = getToken();        Log.d(TAG, token);        // Check if the token is null or empty        if (token == null || token.isEmpty()) {            Log.e(TAG, "Token is missing or invalid");            Toast.makeText(this, "Token is missing or invalid", Toast.LENGTH_SHORT).show();            return;        }        // Create SendMessageRequest with appropriate data        String chapterCurriculumId = "6799fff3db0e4a39f88c19c9" +                ""; // Example chapter ID        String discussionId = "6799fff4db0e4a39f88c19d3"; // Example discussion ID        String messageType = "text"; // Assuming it's a text message        SendMessageRequest sendMessageRequest = new SendMessageRequest(chapterCurriculumId, discussionId, messageType, messageContent);        // Make the API call        ApiService apiService = RetrofitClient.getClient().create(ApiService.class);        Call<Void> call = apiService.sendMessageInDiscussion("Bearer " + token, sendMessageRequest);        call.enqueue(new Callback<Void>() {            @Override            public void onResponse(Call<Void> call, Response<Void> response) {                if (response.isSuccessful()) {                    Log.d(TAG, "Message sent successfully");                    Toast.makeText(MainActivity.this, "Message sent successfully", Toast.LENGTH_SHORT).show();                    // Assuming you want to add the sent message to the RecyclerView                    // Create a Message object for the sent message                SenderDetails sender = new SenderDetails("you", "", "" +                        ""); // Modify based on actual sender info                    Message sentMessage = new Message(messageContent, getCurrentTimestamp(), sender, true); // true since it's sent by the user                    // Make sure to update the RecyclerView on the main thread                    runOnUiThread(new Runnable() {                        @Override                        public void run() {                            Log.d(TAG, "Adapter item count before: " + messageAdapter.getItemCount());                            // Add the sent message to the messages list and notify the adapter                            messagesList.add(sentMessage);                            messageAdapter.addMessages(List.of(sentMessage));  // Use addMessages to notify item inserted                            Log.d(TAG, "Adapter item count after: " + messageAdapter.getItemCount());                        }                    });                    // Clear the input field after sending the message                    inputMessage.setText("");                } else {                    Log.e(TAG, "Error sending message: " + response.code());                    Toast.makeText(MainActivity.this, "Failed to send message", Toast.LENGTH_SHORT).show();                }            }            @Override            public void onFailure(Call<Void> call, Throwable t) {                Log.e(TAG, "API call failed: " + t.getMessage());                Toast.makeText(MainActivity.this, "Error occurred while sending message", Toast.LENGTH_SHORT).show();            }        });    }    private String getCurrentTimestamp() {        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault());        return sdf.format(new Date());    }    private void initializeSocketConnection() {        try {            // Append the token as a query parameter            String socketUrlWithToken = SOCKET_URL;            IO.Options options = new IO.Options();            options.query = "token=" + token; // Pass token as a query parameter            mSocket = IO.socket(socketUrlWithToken, options);            mSocket.connect();            mSocket.on("new-message", onNewMessage);            mSocket.on(Socket.EVENT_CONNECT, args -> {                Log.d(TAG, "Socket connected to URL: " + SOCKET_URL); // Log the URL                runOnUiThread(() -> Toast.makeText(this, "Connected to server", Toast.LENGTH_SHORT).show());                joinDiscussionRoom();//                Log.d(TAG, "Server acknowledged joining discussion: " + args[0]);// Join the discussion room            });            mSocket.on(Socket.EVENT_DISCONNECT, args -> {                Log.d(TAG, "Socket disconnected");                runOnUiThread(() -> Toast.makeText(this, "Disconnected from server", Toast.LENGTH_SHORT).show());                // Reconnect once after disconnect                mSocket.connect();            });;            mSocket.on(Socket.EVENT_CONNECT_ERROR, args -> {                // Log the connection error for debugging                if (args != null && args.length > 0) {                    Log.e(TAG, "Connection error: " + args[0].toString());                } else {                    Log.e(TAG, "Connection error: No error details provided.");                }                // Make sure you're on the UI thread when showing a Toast                runOnUiThread(() -> {                    String errorMessage = "Connection error";                    if (args != null && args.length > 0) {                        // Display the error message received                        errorMessage = args[0].toString();                    }                    Toast.makeText(this, errorMessage, Toast.LENGTH_SHORT).show();                });            });            // Socket event listeners            mSocket.on("get-message", onNewMessage);            // New event to fetch messages when joining the discussion            mSocket.on("fetch-messages", onMessagesFetched);        } catch (URISyntaxException e) {            Log.e(TAG, "Error initializing socket: " + e.getMessage(), e);            Toast.makeText(this, "Error initializing socket", Toast.LENGTH_SHORT).show();        }    }    private void setupListeners() {        sendMessageButton.setOnClickListener(v -> {            String message = inputMessage.getText().toString().trim();            if (!message.isEmpty()) {                sendMessage();                inputMessage.setText("");            } else {                Toast.makeText(MainActivity.this, "Message cannot be empty", Toast.LENGTH_SHORT).show();            }        });    }    private void joinDiscussionRoom() {        JSONObject data = new JSONObject();        try {            // Adding discussion ID to the data            data.put("discussionId", discussionId);            // Log the data that will be emitted            Log.d(TAG, "Emitting join-discussion event with data: " + data.toString());            // Emit the event            mSocket.emit("join-discussion", data);            Log.d(TAG, "Join discussion event emitted.");            // Fetch messages after emitting        fetchMessages();        } catch (JSONException e) {            Log.e(TAG, "Error creating JSON object for joining discussion: " + e.getMessage(), e);        }    }    private int currentPage = 1;    private int limit=585;    private int totalPages = 286;    private boolean isLoading = false;    int totalMessages = 572;    private void fetchMessages() {        if (isLoading || currentPage > totalPages) {            return;        }        isLoading = true;        ApiService apiService = RetrofitClient.getClient().create(ApiService.class);        Call<MessageResponse> call = apiService.fetchMessages("Bearer " + token, discussionId, currentPage, limit);        call.enqueue(new Callback<MessageResponse>() {            @Override            public void onResponse(Call<MessageResponse> call, Response<MessageResponse> response) {                isLoading = false;                if (response.isSuccessful()) {                    MessageResponse messageResponse = response.body();                    if (messageResponse != null && messageResponse.isSuccess()) {                        List<Message> newMessages = new ArrayList<>();                        // User's email (fetch it dynamically from your user session if needed)                        // String userEmail = "demo@gmail.com";                        SharedPreferences sharedPreferences = getSharedPreferences("UserPrefs", MODE_PRIVATE);                        String userEmail = sharedPreferences.getString("user_email", "default_email@example.com");                        Log.d("SSSSSSSSS",userEmail);                        for (MessageResponse.MessageData messageData : messageResponse.getData()) {                            SenderDetails sender = null;                            boolean isSentByUser = false;                            if (messageData.getSenderDetails() != null && !messageData.getSenderDetails().isEmpty()) {                                SenderDetails senderDetail = messageData.getSenderDetails().get(0);                                sender = new SenderDetails(                                        senderDetail.getFirstName(),                                        senderDetail.getLastName(),                                        senderDetail.getEmail()                                );                                isSentByUser = userEmail.equals(senderDetail.getEmail());                            }                            Message message = new Message(                                    messageData.getContent(),                                    messageData.getTimestamp(),                                    sender,                                    isSentByUser                            );                            if (!messageData.getContent().equals("Message to be removed")) {                                newMessages.add(message);                            }                        }                        // Reverse the list for correct order                        Collections.reverse(newMessages);                        if (currentPage == 1) {                            messageAdapter.setMessages(newMessages); // Set new data                            messageAdapter.notifyDataSetChanged(); // Efficient update                        } else {                            messageAdapter.setMessages(newMessages); // Set new data                            messageAdapter.notifyDataSetChanged();                        }                        totalPages = messageResponse.getTotalPages();                        currentPage++;                        // Scroll to the latest message if the user is at the bottom                        chatRecycview.postDelayed(() -> {                            if (isUserAtBottom()) {                                chatRecycview.scrollToPosition(messageAdapter.getItemCount() - 1);                            }                        }, 50);                    } else {                        Toast.makeText(MainActivity.this, "Failed to fetch messages", Toast.LENGTH_SHORT).show();                    }                } else {                    Toast.makeText(MainActivity.this, "Error fetching messages", Toast.LENGTH_SHORT).show();                }            }            @Override            public void onFailure(Call<MessageResponse> call, Throwable t) {                isLoading = false;                Toast.makeText(MainActivity.this, "Error occurred while fetching messages", Toast.LENGTH_SHORT).show();                Log.d("mes fetch", t.toString());            }        });    }    private boolean isUserAtBottom() {        LinearLayoutManager layoutManager = (LinearLayoutManager) chatRecycview.getLayoutManager();        if (layoutManager != null) {            int lastVisiblePosition = layoutManager.findLastVisibleItemPosition();            int totalItemCount = layoutManager.getItemCount();            // Check if the last visible item is the last item in the adapter            return lastVisiblePosition == totalItemCount - 1;        }        return false;    }    private final Emitter.Listener onNewMessage = args -> runOnUiThread(() -> {        if (args[0] instanceof JSONObject) {            JSONObject data = (JSONObject) args[0];            Log.d(TAG, "Received message data: " + data.toString());  // Log incoming data for debugging            String message = data.optString("content", "No message content");            JSONObject senderDetailsJson = data.optJSONObject("senderDetails");            String senderName = "Unknown";            String senderEmail = "Unknown";            boolean isSentByUser = false;            if (senderDetailsJson != null) {                String firstName = senderDetailsJson.optString("firstName", "Unknown");                String lastName = senderDetailsJson.optString("lastName", "");                senderName = firstName + " " + lastName;                senderEmail = senderDetailsJson.optString("email", "Unknown");            }            long timestamp = data.optLong("timestamp", System.currentTimeMillis());            SenderDetails senderDetails = new SenderDetails(senderName, "", senderEmail);            SharedPreferences sharedPreferences = getSharedPreferences("UserPrefs", MODE_PRIVATE);            String currentUserEmail = sharedPreferences.getString("user_email", "default_email@example.com");// Fetch from preferences or auth service            isSentByUser = currentUserEmail.equals(senderEmail);            Log.d("currentUserEmail",currentUserEmail);            // Create the message object            Message messageContent = new Message(message, String.valueOf(timestamp), senderDetails, isSentByUser);            // Only add new messages from other users to the list            if (!isSentByUser) {                // Add new message at the top (if you want latest messages at the top)                messagesList.add(0, messageContent);                messageAdapter.notifyItemInserted(0); // Notify adapter efficiently                chatRecycview.scrollToPosition(0); // Scroll to the latest message            }            // Optionally, log and toast the new message for feedback            Log.d(TAG, "New message received: " + messageContent.getContent());            Toast.makeText(MainActivity.this, "New message: " + messageContent.getContent(), Toast.LENGTH_SHORT).show();        }    });    private final Emitter.Listener onMessagesFetched = args -> runOnUiThread(() -> {        try {            JSONObject data = (JSONObject) args[0];            JSONArray messages = data.getJSONArray("data");            List<Message> fetchedMessages = new ArrayList<>();            for (int i = 0; i < messages.length(); i++) {                JSONObject message = messages.getJSONObject(i);                String content = message.getString("content");                SenderDetails senderDetails = new SenderDetails("Unknown", "", "");                boolean isSentByUser = false;                Message messageObj = new Message(content, String.valueOf(System.currentTimeMillis()), senderDetails, isSentByUser);                fetchedMessages.add(messageObj);            }            updateMessageList(fetchedMessages);  // Update RecyclerView with new messages        } catch (JSONException e) {            Log.e(TAG, "Error fetching messages: " + e.getMessage(), e);            Toast.makeText(MainActivity.this, "Error fetching messages", Toast.LENGTH_SHORT).show();        }    });    @Override    protected void onDestroy() {        super.onDestroy();        mSocket.disconnect();        mSocket.off(Socket.EVENT_CONNECT);        mSocket.off(Socket.EVENT_DISCONNECT);        mSocket.off(Socket.EVENT_CONNECT_ERROR);        mSocket.off("get-message", onNewMessage);        mSocket.off("fetch-messages", onMessagesFetched);    }    @Override    protected void onResume() {        super.onResume();        // Ensure the socket is connected or reconnected on resume        if (!mSocket.connected()) {            mSocket.connect();        }        // Make sure messages are updated        messageAdapter.setMessages(messagesList);    }    @Override    protected void onPause() {        super.onPause();        // Disconnect the socket when the app goes to the background        if (mSocket != null && mSocket.connected()) {            mSocket.disconnect();        }    }}